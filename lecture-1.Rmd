---
title: 'Введение в R/Python <br> "Количественные финансы" '
author: "Салихов Марсель (marcel.salikhov@gmail.com)"
date: "`r Sys.Date()`"
output:
  slidy_presentation:
    css: styles.css
    logo: logo_hse_wide.jpg
    footer: НИУ ВШЭ, 2021. Салихов Марсель (marcel.salikhov@gmail.com)
    lib_dir: libs
    self_contained: no
---

   
## Цели лекции 
   
+ понять, что такое **R и Python**, в чем их достоинства как инструмента количественного анализа
+ получить **базовые представления** об основных командах и типах данных в R/Python
+ понять, что такое **векторизация** 
+ научиться работать с финансовыми данными
+ научиться работать с датами в R/Python 
+ получить навыки работы с временными рядами в R/Python
+ узнать, как можно строить графики в R/Python


## Что такое R?

+ R -- язык программирования и платформа для статистического анализа, построения визуализаций/графиков и много другого. К примеру, эта презентация сделана в R. 
+ R -- наиболее широко используемое в мире средство для статистического анализа. 

## Что такое Python?

+ Python -- один из наиболее широко используемых языков программирования. 
+ Python -- наиболее широко используемое в мире средство для анализа данных и машинного обучения. 


## Ресурсы для обучения 

R:

+ Базовый курс ["Introduction to R"](https://app.datacamp.com/learn/courses/free-introduction-to-r)
+ Курс ["R Programming"](https://www.coursera.org/learn/r-programming) by Roger Peng 
+ Курс ["Основы программирования на R"](https://stepik.org/course/497/promo)


Python: 

 + Базовый курс ["Python Fundamentals"](https://app.datacamp.com/learn/skill-tracks/python-fundamentals)
 + ["Getting started with Python for science"](http://scipy-lectures.org/intro/index.html)
 + ["Quantitative Economics with Python¶"](https://python.quantecon.org/intro.html)
 


## Почему именно R/Python? 

+ Устоявшиеся, достаточно простые и эффективные **языки программирования**. Фактически - стандарты в настоящее время в области data science. 
+ Выполнение аналитической задачи **в форме кода** имеет большие преимущества: проще автоматизировать выполнение сложных задач, проще находить ошибки, проще вспомнить потом, что же было сделано.
+ **Reproducible research** -- принцип проведения исследований в современном мире.
+ R/Python имеют огромную экосистему дополнительного функционала (пакетов), которые расширяют базовые возможности. Практически все современные статистические методы, которые вы можете себе представить, имеют реализацию в R. Все соврменные ML-инструменты доступны на Python. И все это -- бесплатно! 
+ R/Python имеют богатый функционал по построению графиков и **визуализации данных**. Возможностей гораздо больше, чем в Excel! 
+ Большая пользовательская база и эко-система. На [stackoverflow.com](https://stackoverflow.com/questions/tagged/r) в настоящее время задано около 1,8 млн вопросов по Python и около 420 тыс. вопросов по R. Python и R входит в топ-20 наиболее популярных языков программирования 2021 года по индексу [TIOBE](https://www.tiobe.com/tiobe-index/). Python - 1 место, R - 14 место. 
+ Вы  можете можете посмотреть исходный код  функции из любого пакета и понять, как реализуется тот или иной метод -- это не "черный ящик". 
+ R/Python работают на всех современных платформах -- **Windows/Mac OS/Unix**. R/Python могут работать и в браузере или "в облаке".  


Этот график построен в R: 

```{r , echo = FALSE,warning=FALSE, message=FALSE, tidy.method = "styler"}

library(plotly,  warn.conflicts = FALSE, quietly = TRUE)
z <- c(
  c(8.83,8.89,8.81,8.87,8.9,8.87),
  c(8.89,8.94,8.85,8.94,8.96,8.92),
  c(8.84,8.9,8.82,8.92,8.93,8.91),
  c(8.79,8.85,8.79,8.9,8.94,8.92),
  c(8.79,8.88,8.81,8.9,8.95,8.92),
  c(8.8,8.82,8.78,8.91,8.94,8.92),
  c(8.75,8.78,8.77,8.91,8.95,8.92),
  c(8.8,8.8,8.77,8.91,8.95,8.94),
  c(8.74,8.81,8.76,8.93,8.98,8.99),
  c(8.89,8.99,8.92,9.1,9.13,9.11),
  c(8.97,8.97,8.91,9.09,9.11,9.11),
  c(9.04,9.08,9.05,9.25,9.28,9.27),
  c(9,9.01,9,9.2,9.23,9.2),
  c(8.99,8.99,8.98,9.18,9.2,9.19),
  c(8.93,8.97,8.97,9.18,9.2,9.18)
)
dim(z) <- c(15,6)
z2 <- z + 1
z3 <- z - 1

p <- plot_ly(showscale = FALSE) %>%
  add_surface(z = ~z) %>%
  add_surface(z = ~z2, opacity = 0.98) %>%
  add_surface(z = ~z3, opacity = 0.98)


p
```


```{r, echo=FALSE}
library(reticulate)
use_python('D:/Anaconda3/')
```


## Примеры финансовых моделей, сделанные в R

1. [Факторы доходностей российского рынка акций](http://models.fief.ru/shiny/ffmonthly/)
2. [Оптимальный портфель ETF на Московской Бирже](http://models.fief.ru/shiny/portfolio/)
3. [PORTFOLIO VISUALIZER](https://www.portfoliovisualizer.com/)



## Ограничения R/Python

+ **Кривая обучения** -- печатать команды в текстовом виде, а не выполнять манипуляции мышью в графическом интерфейсе с начала может показаться не очень удобным.
+ **Слишком большой выбор**. Многие задачи могут выполняться разными способами, разными функциями -- это запутывает. Python проще в этом этом отношении, R -- сложнее. 
+ **Really BIG Data**. R/Python все данные хранят в оперативной памяти. Объем данных для анализа ограничен памятью. Это ограничивает разработки очень Больших моделей. 
+ **High performance computing**. R/Python не очень хорошо подходят для высокоскоростных вычислений в промышленном использовании или для решения очень больших задач, так как является медленным по сравнению с языками более низкого уровня. Однако основная часть требовательных задач обычно написана на C/C++ и просто имеют "обертку" для R/Python.


## R/Python или Excel?

+ Каждый инструмент -- для своих задач. Надо уметь работать с разными инструментами для того, чтобы решать поставленную задачу оптимальным образом.  
+ **Excel -- отраслевой стандарт в финансах** для выполнения простых и гибких количественных задач. Если вам необходимо "посмотреть" на данные и "потрогать" их, то Excel -- лучший вариант. К примеру, если вы хотите быстро проанализировать финансовую отчетность определенной компании, то удобнее использовать Excel. Если вы хотите проанализировать отчетность 100 компаний и построить регрессию на их финансовых показателях -- удобнее использовать R. 
+ **Несложные расчеты**. Excel  хорошо подходит для построения относительно несложных количественных моделей, так как вы наглядно видите, что происходит. 
+ **Понятные расчеты и связи**. Мы иногда будем использовать Excel для того, чтобы лучше понять суть того или иного метода. 

**НО:**

+ **Размер данных**. Excel не дает работать с данными, даже относительно небольшими по современным стандартам. Попробуйте открыть в Excel файл, который содержит 100 тыс. строк и поработать с ним! 
+ **Сложные модели**. В Excel можно строить сложные модели (и многие это делают!), но в таких моделях сложно найти ошибки (ошибки неизбежны) и поддерживать модели их. Известные примеры -- данные [Reinhart & Rogoff (2010)](https://theconversation.com/the-reinhart-rogoff-error-or-how-not-to-excel-at-economics-13646), риск-менеджмент в [JPMorgan](https://baselinescenario.com/2013/02/09/the-importance-of-excel/). Недавно была [история](https://www.bbc.com/news/technology-54423988) c потерей зафиксированных заражений COVID-19 в Великобритании. 
+ **Скудная статистика**. Excel, по сути, не поддерживает статистические вычисления и операции, кроме самых базовых. К примеру, попробуйте найти, как посчитать медиану в сводных таблицах Excel. 
+ **Финансовые данные**. Excel не оптимально работает с финансовыми данными, хотя Excel - де-факто стандарт для финансовой отрасли. 


## R или Python?

+ **Python** -- универсальный язык программирования, который также широко в качестве средства разработки. R -- специализированный язык для статистических вычислений. 
+ **Охват**. Python имеет одни из наиболее развитых и производительных библиотек для машинного обучения, но "отстает" в части статистических методов и пакетов.
+ **Скорость**. Производительность R и Python обычно сопоставимы между собой, однако Python имеет более удобные средства для оптимизации кода. Python, как правило, имеет более "лаконичный" синтаксис по сравнению с R. 
+ **Популярность**. Python более популярный язык программирования по сравнению с R -> больше перспектив с точки зрения будущих вакансий. 
+ **Ваш выбор**. Вы можете использовать любой из этих вариантов для выполнения работ - R или Python. Вы также можете изучать оба языка.   

## Matlab/Statа/SPSS/EViews?

+ **Matlab** -- пакет прикладных программ для вычислений и язык программирования, разработанный компанией MathWorks. Преимущества -- широкое распространение в отдельных отраслях науки/технологий, высокая скорость работы. Недостатки -- достаточно запутанный синтаксис, коммерческий характер продукта, относительно низкая популярность по сравнению с R/Python. 

**НО: **

+ **Цена**. Стандартная коммерческая лицензия составляет около $800/год на пользователя, и это без дополнительных пакетов, которые могут понадобиться. 
+ **Нишевость**. Другие известные статистические пакеты (Statа, SPSS, EViews) сейчас относительно редко используются в анализе данных. Маловероятно, что вы столкнетесь с ними вне академической работы. 
+ **"Цель оправдывает средства"**. Необходимо выбирать средства под решаемую задачу, сам по себе выбор конкретного инструментария не так важен. 

## Установка R

1. **Установка на ПК**

1.1. Зайти на сайт [CRAN](https://cran.r-project.org/) и установить R.

1.2.  Зайти на  сайт [RStudio](https://www.rstudio.com/) и обязательно установить R Studio -- это более удобный и совершенный редактор (IDE) для R. 

+ R можно установить и на Windows/Mac OS/ Unix -- разницы в функционале не будет.
+ Для того, чтобы устанавливать пакеты необходимо иметь **права администратора**. 
+ Не устанавливайте R в свою рабочую папку, в особенности, если вы используете имя пользователя на кириллице (для Windows - `C:\Users\Вася`). Лучше изменить предлагаемую папку "по умолчанию" на что-то другое (к примеру, `D:\R`). 

2. **Работа в облаке**

Альтернатива -- использование [RStudio Cloud](https://rstudio.cloud/) -- облачного версия компании RStudio. 

[Бесплатный](https://rstudio.cloud/plans/free) план RStudio Cloud включает:

+ 15 часов работы 
+ до 15 проектов 
+ 1 Гигабайт памяти 
+ 1 ядро ЦПУ. 

Этого вполне достаточно для нашей работы. 

3. [**Google Colab**](https://colab.to/r). 

## Установка Python

Существуют много различных вариантов установки Python: 

1. **Google Colab** -- самый просто вариант, но требуется переустановка пакетов при перезапуске. 

+ нужен аккаунт Google 
+ https://colab.research.google.com/?utm_source=scs-index


2. **Conda и Jupyter Notebook**

+ Установить [conda](https://docs.conda.io/projects/conda/en/latest/user-guide/install/index.html)
+ `conda install ipython jupyter` в командной строке 
+ 'jupyter notebook' в командной строке 
+ File -> New Nobeook


3. **Установка на свой ПК** -- для настоящих ценителей. 

+ Согласно [инструкции](https://realpython.com/installing-python/). 
+ установка IDE - VS Code, Sublime или любые другие. 


## Изучение R/Python и лабораторные работы в рамках курса 

+ **Гибридный подход**. Для выполнения лабораторных работ я буду предоставлять часть кода для выполнения задачи. Часть кода вам придется писать самостоятельно.  
+ **Практика**. Лучшая способ научиться чему-либо -- это практика. 
+ **Требования**. Ваша задача - 1) модифицировать код 2) интерпретировать полученные результаты с содержательной точки зрения. 3) писать свой собственный код.  
+ **Критерии оценки**: 1) работа кода - позволяет ли код получить ответы на поставленные вопросы? 2) корректность, содержательность и глубина ваших комментариев
+ **Индивидуальный подход**. У каждого студента - свой компания (тикер), отрасль для анализа и проч., которые назначаются случайным образом. Поэтому напрямую использовать результаты вашего соседа - не получится. 

> ваша модель значима или нет? как ее можно модифицировать? что показывают статистические тесты? 

+ Вы можете дополнительно изучать R/Python для того, чтобы лучше освоить задачи этого курса, а также использовать эти знания в будущем.
+ Помощь по любой команде -- ?название команды в консоли (к примеру, `?type`)
+ Увидеть подсказку по аргументу функции: `название_функции()` + `скобки` + `Tab`


## RStudio -- основы

**RStudio** представляет собой очень удобную среду (IDE) для работы в R, которая сильно облегчается жизнь. 

+ В **консоли** вы можете печатать команды для немедленного исполнения. 
+ Окно "Workspace" (правое верхнее) показывает все активные объекты/переменные (`Environment`). Вкладка `History` показывает все команды, которые вы вводили с начала сеанса работы. 
+ Вкладка «Files» отображает все файлы и папки в рабочем пространстве по умолчанию. На вкладке «Plots» будут показаны все ваши графики. На вкладке `packages` будет отображаться серия пакетов или надстроек, необходимых для запуска определенных процессов. Дополнительную информацию см. на вкладке `help`
+ Войдите в RStudio Cloud, чтобы начать самостоятельную работу. 


Изучите [cheat sheet](https://github.com/rstudio/cheatsheets/raw/master/rstudio-ide.pdf) по работе в Rstudio

## JupyterLab -- основы 

+ **Используют все**. Ноутбуки Jupyter представляют собой стандартный способ, с помощью которого аналитики делятся результатами своей работы в Python. 
+ Отличие от традиционной среды в том, что код можно разбить на куски и выполнять их в произвольном порядке.
+ **Гибрид кода и текста**. Блокнот объединяет код и его вывод в единый документ, который объединяет визуализацию, повествовательный текст
+ `cell` (Ячейка) — это контейнер для текста, который будет отображаться в записной книжке, или код, который будет выполняться ядром записной книжки.
+ Ячейка `Markdown` содержит текст, отформатированный с использованием Markdown, и отображает его вывод на месте при запуске. Если вы не знаете формат markdown - имеет смысл сделать это. 

[Попробуйте!](https://jupyter.org/try)

## Базовые операции в R/Python

Начнем с основ: 
   
   ```{r , echo = TRUE}
#R
print("Hello world!")
```

или на Python

```{python}
#Python
print("Hello, world!")
```

Сообщения, начинающиеся со знака `##`, -- показывают результат вывода в консоли R. 

R/Python работают и как калькулятор. Можно складывать переменные: 
   
```{r, echo = TRUE}
1+3

```

умножать:
   
```{r, echo = TRUE}
2*3
```

делить: 

```{r, echo = TRUE}
6/2
```

извлекать квадратный корень: 
   
```{r, echo = TRUE}
sqrt(5)
```

```{python}
#Python
import numpy as np
np.sqrt(5)
```

брать логарифм

```{r, echo = TRUE}
#R
log(5)
```

```{python}
#Python
import numpy as np
np.log(5)
```

возводить в степень 

```{r, echo = TRUE}
#R
2^10
```
```{python}
#Python
pow(2,10)

```


## Операторы сравнения

логические операторы в R и Python имеют одинаковый синтаксис

```{r}
2 > 1 # больше  
5 >= 5 # больше или равно
2 == 2 # Равно 
1 != 0 # не равно

```

```{python}
#Python
2 > 1 # больше  
5 >= 5 # больше или равно
2 == 2 # Равно 
1 != 0 # не равно


```

## Присваивание 

Оператор присваивания присваивает знание различным типам переменным. 

**R**
   В R Можно использовать `=` или `<-` -- они идентичны. Обычно используется `<-`. 
В Rstudio есть удобное сочетание клавиш `Alt - ` для того, чтобы написать эту команду. 



```{r, echo = TRUE}
x = 10 # присвоить переменной x значение 10
y <- x # присвоить переменной y значение переменной x
print(y)

```

**Python** 
   
```{python}
#Python
x = 10 # присвоить переменной x значение 10
y = x # присвоить переменной y значение переменной x
print(y)

```

## Типы данных 

+ Всё в Python/R -- **объекты**. 
+ R/Python оперирует именованными структурами данным. Каждый объект имеет свое **имя**. 
+ Каждый объект имет свой тип. Наиболее понятный тип - числа. 
+ Числа могут быть разных типов - целыми (integer) или дробными (float). Разделение связано с тем, как компьютер хранит числа. 

```{r, echo = TRUE}
2^10
```

Ими могут быть, десятичные числа. Они называются `numeric`. 

```{r, echo = TRUE}
# R
x <- 10.0       # присвоить переменной x значение 10.5
x              # вывести значение x
class(x)       # класс переменной 
typeof(x)      # тип переменной X  
is.numeric(x)
```

в Python

```{python}
# Python
x = 10.0
print(x)
type(x)
type(int(x))
```


```{r}
#R
x = 5 
x = x+5 
x 
```


```{python}
#Python
x = 5
x+=5 # эквивалентно x = x + 5
print(x)
```

## Целые числа 

Тип `integer`. 

```{r, echo = TRUE}
#R
x = as.integer(3)       # присвоить переменной x значение 3
y = 10L
x              # вывести значение x
class(x)       # тип переменной х 
is.integer(x)   # является ли x целым числом?
is.integer(y)

```


```{python, echo = TRUE}
#Python
x = 3
type(x)    # тип переменной х 

y = 3.0
type(y)    # тип переменной y 

isinstance(x, int) # Относился ли x к классу int?
isinstance(y, int)
```

## Логические переменные 

```{r, echo = TRUE}
# R
x = 1; y = 2   # sample values 
z = x > y 
z  
class(z)   
```

Логические операции 

```{python}
# 
u = True; v = False 
u and v          # u AND v 
u or v          # u OR v 
not u      

```

## Тип character/ string

+ `character` в R, 'string' в Python -- строковая переменная. 
+ в R/Python объекты этого типа выделены кавычками. 

```{r}
#R
x <- 1  # присвоить x численное значение 1 
y <- '1' # присвоить y текстовое значение равное 1 
as.numeric(y) # преобразовать y в тип numeric 
## попробуйте команду x + y , будет сообщение об ошибке 

```

в Python

```{python}
#Python
x  = 1  # присвоить x численное значение 1 
y = '1' # присвоить y текстовое значение равное 1 
int(y) # преобразовать y в тип integer 
float(y) # преобразовать y в тип float
print(x + int(y))

```


Обращайте внимание на такой, какой тип имеет переменная с которой вы работаете. 

## Тип NA / NaN

В R есть специальный тип для обозначения **пропущенных данных** (missing value).  


```{r}
#R
x <- NA 
is.na(x)
is.na(c(1, NA))
is.na(2)
```


В Python есть отдельный тип `NaN` -- not a number. Это специальный численный тип для значений, которые не определены или которые не могут быть представлены. 

```{python}
#Python
x = float("NaN")
type(x)

import math
x1 = math.nan
print(x1)
print(math.isnan(x1))

x == x1 # NaN не равен ничему -- даже другому NaN!

```

## Вектор

Вектор -- тип данных, который состоит из упорядоченного набора объектов одного типа. 
В R вектор можно создать с помощью команды `c`.

```{r}
# R
a <- c(1, 2, 3)
b <- c(4,5,6)
is.vector(a) ## является ли a вектором

n = c(2, 3, 5) 
s = c("aa", "bb", "cc", "dd", "ee") 
c(n, s) 

```

```{python}
import numpy as np

a = [1,2,3] # список - лист
a = np.array(a)
print(a)
type(a)

```

Есть и другие варианты для создания векторов: 
   
```{r}
# R
1:10
seq(from = 2, to = 10, by = 2)
seq(from = 1, by = 2, length.out = 5)
rep(1:4,2)
rep(1:4, each = 2)
```

```{python}
#Python
import numpy as np

np.arange(10)
np.arange(2, 10, 2)
np.linspace(1,2,5)
np.repeat(np.arange(1,5,1), 2)

```

Для векторов одинаковой длины операции совершают поэлементно.

У каждого вектора есть свой индекс (порядковый номер), к которому можно обратиться с помощью имени объекта (вектора) и **квадратных скобок**. Индекс начинается с '1' (а не с 0 как в Python!). Знак минус (`-`) исключает данный индекс из вектора. 

```{r}
#R
s = c("a", "b", "c", "d", "e") 
s[3] # третий элемент
s[10] # нет 10 элемента, поэтому NA
s[1:3] # элементы с 1 по 3
s[c(1,3,5)] # оставить элементы 1,3 и 5
s[-3] # убрать третий элемент
s[-(1:2)] # убрать элементы 1 и 2 
```


```{python}
#Python
import numpy as np

s = np.array(["a", "b", "c", "d", "e"])

print(s)
s[3]
#s[10]
s[1:3]
s[[0,2,4]]
s[-2:]
s[-3:]

```


## Векторизация операций

+ Преимущество R/Python -- так называемая **векторизация операций**. Это означает, что вы можете осуществлять операции над векторами, точно так же, как и над отдельными числами. 
+ Векторизация обеспечивает скорость, а также избавляет от необходимости писать циклы `for`.
+ На самом деле любой единичный объект -- это вектор с длиной 1.

```{r}
#R
a 
b
a+b
a *b
log(a)

```

Операции могут выполняться и с векторами разной длины. В этом случае используется "выравнивание векторов"" (recycling rule). 

```{r}
u = c(10, 20, 30) 
v = c(1, 2, 3, 4, 5, 6, 7, 8, 9) 
u + v 
```

В чем оно заключается? 

с помощью функции 'length' можно узнать длину вектора 

```{r}
u = c(10, 20, 30) 
length(u)
```

```{python}
#Python
u = np.array([10,20,30])
u + 1
u*2 
np.log(u)

v = np.array([1,2,3])
u + v 

len(u) # длина вектора 
```

## Тип data frame 

`data frame` -- это набор (коллекция) векторов, объединенных в один объект. Каждый столбец `data frame` -- вектор. Каждая строка -- наблюдение. Большинство структурированных данных хранится в качестве `data frame`.

```{r}
str(mtcars) # посмотреть структуру объекта  
dim(mtcars) # размерность объекта, количество наблюдений и переменных 
length(mtcars) # длина -- количество переменных 
head(mtcars) # первые 5 строк 
head(mtcars, n = 2) # first 2 rows of data.frame
tail(mtcars) # последние 5 строк 
tail(mtcars, n = 3) # last 3 rows of data.frame
```

Существуют разные способы обратиться к элементам `data frame`.

К примеру, к отдельной колонке (переменной) можно обратиться следующими способами:
```{r}
mtcars[9] #  номер внутри двойных скобок
class(mtcars[9])
mtcars[[9]] #  номер внутри двойных скобок
class(mtcars[[9]])
mtcars$am
mtcars[, 'am']
```
К строкам можно обратиться следующими способами: 

```{r}
mtcars[24,] # индекс по номеру 
mtcars[c(3, 24),] #3,24 строка

L = mtcars$am == 0 
L
 mtcars[L,] 
```

Изучите [cheet sheet](http://github.com/rstudio/cheatsheets/raw/master/base-r.pdf) по базовым функциям R. 

## Pandas 

`pandas` -- основной пакет для работы и обработки данных. 

`Series` - это одномерный массив индексированных данных. Его можно создать из списка или массива следующим образом:

```{python}
import pandas as pd

data = pd.Series([0.25, 0.5, 0.75, 1.0])
data

data.values
data.index


```

`DataFrame`


```{python}
company = ["MSFT", "AAPL", "XOM"]
sales = [100,200,150]
profit = [20,-10,30
]
a = pd.DataFrame({'company': company,
              'sales': sales})
a 

b = pd.DataFrame({'sales': sales, "profit": profit}, index = company)
b
b.index
             
```

ссылки и срезы 

```{python}
b["profit"]
```
```{python}
b["margin"] = b.profit / b.sales
b
```

```{python}
ix = b["profit"] > 0 
b[ix]

```
```{python}
b["sales"] # возвращает Series
b[["sales"]] # возвращает DataFrame
```


```{python}
b.loc[ix, ["sales"]]
```
`DataFrame`: содержит данные в виде таблиц для упрощения манипуляций и построния отдельных срезов.

Создание:
+ можно построить по строке или по столбцу
+ можно прочитать из файла или из Интернета

Основные части:
+ данные
+ индекс (id)
+ столбцы
Выбор деталей:


Пока мы работали только над одним датафреймом , также можно объеединять/комбинировать датафреймы.


## Даты

+ Финансовые данные практически всегда имеют временной характер, то есть привязаны ко времени. 

### Тип Date в R

Тип `Date` представляет календарные даты.
Финансовые серии как правило представляют собой временный ряд, упорядоченный во времени. Поэтому эффективная работа с данными важна для финансового анализа 

```{r}
date()
today <- Sys.Date()
today
class(today)
as.numeric(today) # внутри переменная Date представляет собой количество дней с 1 января 1970 года

```

Даты можно представлять различным образом с помощью функции `format`

```{r}
format(today,  format = "%d %b %Y")  # with month as a word

```



| Символ | Значение                 | Пример  |
|--------|--------------------------|---------|
| %d     | день как число (0-31)    | 31      |
| %a     | сокращенный  день недели | вт      |
| %A     | день недели              | Вторник |
| %m     | месяц (00-12)            | 00-12   |
| %b     | сокращенный месяц        | ноя     |
| %B     | полный месяц             | ноября  |
| %y     | 2-значный год            | 18      |
| %Y     | 4-значный год            | 2018    |


Что делать, если мы хотим даты на английском языке? 

Нужно поменять параметры языка для вашей системы и потом вернуть их обратно: 


```{r}
Sys.getlocale() #"ru_RU.UTF-8/ru_RU.UTF-8/ru_RU.UTF-8/C/ru_RU.UTF-8/ru_RU.UTF-8" или "=Russian_Russia.1251" (в Windows)

Sys.setlocale(locale = 'C')
format(today,  format = "%d %b %Y")  # with month as a word
Sys.setlocale(locale = "ru_RU.UTF-8")


```

можно создавать вектора дат 

```{r}
dt = seq(today, length.out=10, by="1 week")
dt
weekdays(today)
months(today)
```

```{r}
dt -1

```


Можно делать конвертацию между типами `character` и `Date` c помощью функций `as.Date` и `as.character`.

```{r}
as.character(today)
str = '2018-11-06' #  yyyy-mm-dd - стандартный формат представления даты 
as.Date(str)
as.Date('2018 ноября 6', format = '%Y %B %d')

```

преобразуйте в тип Date следующую строку: `16 ноя, 2018`.

### Даты в Python

```{python}
t1 = pd.Timestamp('2021-11-15')
t2 = pd.Timestamp('2021-11-19')

t1, t2
```

```{python}
(t2-t1).days
```


```{python}
t1.year == t2.year
```


```{python}
from datetime import date

dt3 = date(2021, 10, 25)
dt4 = date(2021, 10, 29)
```


### Даты в Excel 

Вы, наверняка, сталкивалась с тем, что Excel воспринимает даты как целые числа -- что-то вроде `43831`. Это связано с тем, что дата в Excel -- это число дней с 30 декабря 1899 года. `43831` -- это 1 января 2020 года. 

Вы можете преобразовать прочитанные в Excel даты в тип даты R

```{r}
as.Date(43831, origin = "1899-12-30")

```




