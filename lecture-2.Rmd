---
title: 'Основные особенности финансовых серий и построение AR-моделей <br> "Количественные финансы" '
author: "Салихов Марсель (marcel.salikhov@gmail.com)"
date: "`r Sys.Date()`"
output:
  slidy_presentation:
    css: styles.css
    footer: НИУ ВШЭ. Салихов Марсель (marcel.salikhov@gmail.com)
    lib_dir: libs
    self_contained: no
    
---
   
## Цели лекции 
   
+ разобраться в чем основные особенности финансовых серий
+ почему стационарность это важно?
+ понять, что такое автокорреляция (serial correlation)
+ понять базовые принципы построения моделей временных рядов


## Пакеты и работа с пакетами в R/Python

**R**

Стандартная версия R включает несколько базовых пакетов, которые включают в себя встроенные функции и операции. Однако сила R основана на использовании дополнительных пакетов, которые расширяют базовый функционал. Мы будем использовать несколько разных дополнительных пакетов. 

Для использования пакета его сначала надо установить с помощью команды `install.packages` -- это приводит к тому, что пакет скачивается из Интернета и устанавливается на ваш компьютер. Затем надо загрузить пакет для использования в работе с помощью команды  'library'. 


```{r, }
#install.packages(xts) # установать пакет 
library(xts) # загрузить пакет

```

данная команда установит пакет, если он ранее не был установлен:

```{r}
if (!require("lubridate")) install.packages("lubridate")
```


**Python** 

Python использует аналогичную логику установки пакектов

```{python}
import numpy as np
# загрузить пакет numpy и использовать название np для него
```

`pip install numpy` -- установка пакета numpy с помощью менеджера пакетов pip
`conda install numpy` -- установка пакета с использованием conda 

## Пакет lubridate облегчит работу с данными в R

```{r}
library(lubridate)
dt <- Sys.Date()
dt 
month(dt) # номер месяца
wday(dt) # номер для недели 
leap_year(dt) # високосный год?

```
Посмотрите [cheat sheet](https://github.com/rstudio/cheatsheets/raw/master/lubridate.pdf) по работе с данными в R

## 


## Загрузка данных в R/Python

Существует несколько возможных загрузить данные в R/Python: 

+ из файлов. R/Python может прочитать большинство файлов с данными, включая csv, xlsx, dbf, dta и другие 
+ напрямую из Интернета. 
+ встроенные датасеты 


В рамках наших лабораторных работ мы будем использовать преимущественно загрузку напрямую через Интернет. 

## Тип xts -- временной ряд 

В R есть несколько специальных типов данных для работы с временными рядами.
Один из них -- `xts` (extendible time series).

```{r}

data(sample_matrix)

df_xts <- as.xts(as.data.frame(sample_matrix),
                 important = 'very important info!')
str(df_xts)

xts(1:10, Sys.Date()+1:10)

head(index(df_xts))
head(coredata(df_xts))
```

Основное удобство работы с объектами типа `xts` --  удобные способы получать срезы исходных данных и возможность работать с датами:

```{r}
df_xts['2007-01-06'] # отдельная дата 
df_xts['2007-03'] # отдельный месяц 

head(df_xts['/2007-01-07']) # с начала до 7 января 2007
head(df_xts['2007-06-25/']) # с 25 июня 2007 года до конца 
head(df_xts["2007"])
df_xts['2007-03']


```

```{r}
first(df_xts, '1 week') # 1 неделя 
first(last(df_xts,'1 week'),'3 days') # что это означает? 

```



```{r}
head(coredata(df_xts))
head(index(df_xts))
tzone(df_xts)
```

```{r}
 days <- c("2007-05-03","2007-05-23")
df_xts[days]
```


## Трансформация перидиодичности ряда 

`xts` предоставляет возможность менять периодичность данных 

```{r}
to.monthly(df_xts)
to.weekly(df_xts)
nmonths(df_xts)
```

## Построение графиков в R/Python 

+ Существует несколько разных систем для построения графиков. В данном случае мы используем базовую (base) систему.
+ Команда `rnorm` в R используется для генерирования случайных чисел, распределенных нормально $~N(0,1)$. 

```{r}
#R
x = 1:100
y = rnorm(100)

plot(x = x,y =y , type = 'l')
hist(rnorm(100))

```

```{python}
import numpy as np
import matplotlib.pyplot as plt

x = np.arange(100)
y = np.random.normal(0,1,100)

plt.plot(x, y)
plt.show()

plt.hist(y)
plt.show()

```


## Пример визуализации финансовых данных

```{r, warning=FALSE}
#R
library(quantmod)
AAPL = getSymbols("AAPL", auto.assign = FALSE)
chartSeries(AAPL, theme = 'white') 
chartSeries(AAPL['2017::'], theme = 'white')

chartSeries(AAPL,TA=c(addVo(),addBBands()))  #add volume and Bollinger Bands from TTR


```


```{python}
import yfinance as yf
from datetime import date

import matplotlib.pyplot as plt
#import mplfinance
# 
# today = date.today()
# df = yf.download('AAPL','2020-01-01', today)
# df.tail()
# 
# mplfinance.plot(df.loc['2021-01-1'::],
#             type='candle',
#             style = 'charles',
#             title='Apple stock price',
#             ylabel='Price ($)'
#         )

```


## Расчет лог-доходностей в R/Python


```{r}
#R
aapl_ret <- diff(log(Cl(AAPL))) # расчет лог-доходностей
head(aapl_ret) #
                  

plot(aapl_ret, type = 'l', main = 'AAPL log returns')
```

```{python}
#Python

```



## Статистические тесты 

Статистические тесты из курса эконометрии и статистики можно проводить в R. 

Проверить нулевую гипотезу о том, что среднее доходностей APPL равно нулю. 

```{r}
t.test(aapl_ret)
```

Судя по результатам, мы можем принять альтернативную гипотезу.


## Тесты на стационарность

Обычным тестом на стационарность является тест Дикки-Фуллера (ADF). Нулевой гипотезой для теста является наличие единичного корня (unit root).

```{r}
library(tseries)
adf.test(aapl_ret[-1])

```

Какие выводы можно сделать из теста?



## Тесты на нормальность 

Существует достаточное большое количество статистических тестов для того, чтобы определить как сильно рассматриваемая случайная величина отличается от нормального распределения. 

График квантиль-квантиль позволяет визуально оценить "нормальность". Отклонения от линции указывает наличие тяжелых хвостов в данных. 

```{r}
qqnorm(coredata(aapl_ret))
qqline(coredata(aapl_ret), col = "steelblue", lwd = 2)

```


Часто используемые тесты - тест Kolmogorov-Smirnov,  Shapiro-Wilk, Jarque--Bera. 

Нулевая гипотеза -- величина имеет нормальное распределение. Если p > 0,05 -- можно принять гипотезу о нормальности распределения. 

Тест S-W имеет большую мощность, чем K-S. Поэтому предпочтительно использовать его. 

```{r, warning=FALSE}
library(fBasics)
ksnormTest(coredata(aapl_ret)[-1])

shapiroTest(coredata(aapl_ret)[-1])
```
```{r}
jarqueberaTest(coredata(aapl_ret)[-1])
```


Мы можем отклонить гипотезу о нормальности распределения. 

